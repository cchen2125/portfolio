Design Document for Down Time

Many elements of designing my project was based on finance (pset 9). I used finance as the basis for setting up my flask structure and for creating the log in, register, and log out features of Down Time. Similar to finance, I also used jinja in my templates, and the tables on the analytics page are also based on the tables from finance. In addition, I stored all the data in a SQL database called data.db. This database includes 6 tables: users, goals, sleep, water, exercise, and relaxation. The users data base includes the columns id, username, hash (for the password hash), name, and theme. The goals table includes the columns id, user_id (which corresponds with the id column of the users table), goal, complete (0 if incomplete, 1 if complete), and deleted (0 by default, 1 if deleted). The next four tables each include and id column, a user_id column, and amount column, and a date column. Similar to finance, I used db.execute to edit the SQL database as needed.

The following paragraphs detail how I implemented some features that were not part of finance.   

Some of the pages in my web application had multiple forms on one page, which each served a different purpose. In order to account for this, each form had its own action route. On the app.py document, I have the routes associated with a particular page below the route for the base page (for instance, the sleep, water, exercise, and relax routes are written below the activities route). For these routes, I only had the "post" method allowed.

In order to allow users to change the color scheme of the page, I stored the user's color scheme in the users table of the SQL database. Then, I used a context processor (starting line 41 of app.py) that would allow me to feed the color scheme into every single template. If the user is logged in, the color scheme will be what they chose. Otherwise, the color scheme is light by default. In the layout template, the color is a class for the body tag. In the css file, the background color is set depending on the class. 

To make the graphs on the activities and analytics page, I used matplotlib. For the activities page, I only wanted to display the data from the last week. This required the use of the datetime package, which could be used to get the current day as well as the last 7 days. One website that was extremely helpful in embedding my graphs into the flask templates was: https://matplotlib.org/devdocs/gallery/user_interfaces/web_application_server_sgskip.html

Looking solely at app.py, the recommendations page has the least amount of code. This is because for the recommendations page, I chose to implement the interactivity with JavaScript. Essentially, each button has an event listener waiting for a click. When the button is clicked, the associated list will be shuffled, and the first item on the list will appear on screen. 

While most of the error checking for form inputs could be directly adopted from finance, there was one error check in particular that I had to implement a little differently. This was for validating the amounts input on the activities page. I wanted to make sure that entries were floats (decimals allowed, but negatives not allowed). However, I couldn't find a pre-existing function that could check that for me. Functions like isdigit and isnumeric would return false for decimals and the function isinstance did not check if a string was a float, only returning true if the datatype of the input is already a float. I also wanted to make sure that the user could leave the amount field empty if they wanted to delete a data point. Ultimately, the solution I went with was to try typecasting the amount entry into a float and set res = True if that works and res = False if that did not. That served as my way of checking whether the input was a float or not. I implemented a similar system for checking date entries.

One of the biggest problems I kept encountering was getting Internal Server Errors if the user hadn't input any data yet. Some graphs and some functions required some data input in order to work. Here are some things I did to solve various problems in this category:
-Using AVG(amount) instead of just amount for the SQL select query when generating the activities graphs. Selecting amount made it so that the [0] index didn't exist (and db.execute didn't like that), while selecting AVG(amount) would return a [0] index of None.
-If then statements. For example, on the analytics page, two different pie charts are generated depending if goals exist or not.
-Using a bar chart on the activities page instead of a line chart. If I used a line chart and one particular date didn't have an entry, the line would get broken at that date. By using a bar chart, I could set values that didn't exist to 0, which would preserve the aesthetics of the graph. 

Finally, some concerns I have with my final product:
-I'm a little disappointed that I couldn't figure out how to allow users to add custom activities. I think I probably would have to rethink the SQL database structure and put all the activities into one database somehow for that to work, but I didn't have enough time to figure that out.
-I tried to account for all the possible form errors I could think of, but I worry that I may have missed some.